<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Carpool Matcher</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 1rem;
      background: #f9f9f9;
    }
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .header-container h1 {
      margin: 0;
    }
    h1, h2, h3, h4 {
      margin-top: 0; /* Consistent heading margins */
    }
    button {
      padding: 0.5rem;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 0.5rem; /* Consistent button margin */
    }
     button.secondary {
        background-color: #6c757d;
     }
     button.danger {
        background-color: #dc3545;
     }

    /* Clear Data Button */
    #clearDataBtn {
      background-color: #dc3545;
      margin-left: 1rem;
    }

    /* --- Layout --- */
    .setup-area {
      display: flex;
      gap: 2rem;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #ccc;
    }
    .setup-column {
      flex: 1;
      background-color: #f0f0f0;
      padding: 1rem;
      border-radius: 8px;
      min-height: 200px; /* Ensure columns have some height */
    }
    .setup-column h3 {
      text-align: center;
      border-bottom: 1px solid #ddd;
    }
    .header-actions {
      display: flex;
      gap: 1rem;
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
    }
    .add-button {
      display: block;
      width: 100%;
      padding: 0.8rem;
      font-size: 1.1em;
      margin-bottom: 1rem;
    }
    .swimlane-container {
      display: flex;
      gap: 2rem;
      margin-top: 1rem;
    }
    .board {
      flex: 1;
      background: #eee; /* Differentiate boards */
      padding: 1rem;
      border-radius: 8px;
    }
    .board h3 {
      border-bottom: 1px solid #ccc;
      padding-bottom: 0.5rem;
    }
     .list h4 { /* Style for static headers in allocation boards */
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        font-size: 1em;
        color: #555;
        border-bottom: 1px solid #ddd;
        padding-bottom: 0.3rem;
    }
    .drivers-area {
        display: flex; /* Arrange drivers horizontally */
        flex-direction: column; /* Stack drivers vertically on board */
        gap: 1rem;
       /* overflow-x: auto; */ /* No longer needed if vertical */
        padding-bottom: 1rem;
        min-height: 150px;
        margin-top: 1rem;
        border-top: 1px solid #ddd;
        padding-top: 1rem;
    }
     .driver { /* Driver container ON THE BOARD */
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      padding: 0.8rem; /* Slightly less padding */
      min-width: auto; /* Allow shrinking */
      border-left: 3px solid #6c757d;
    }
     .driver h4 {
        margin: 0 0 0.5rem 0;
     }

    /* --- Visual Item Styles --- */
    .item-container { /* Base for car/child in setup area */
       background: #fff;
       border-radius: 8px;
       box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
       padding: 1rem;
       margin-bottom: 1rem;
       position: relative;
       cursor: grab;
    }
    .item-container.is-configuring {
        box-shadow: 0 0 10px rgba(255, 165, 0, 0.7);
        cursor: default;
    }
    .car-container {
        border-left: 5px solid #3498db;
    }
    .child-card {
        border-left: 5px solid #f1c40f;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .item-container h4 {
        margin: 0 0 0.5rem 0;
        display: inline-block;
    }
    .item-controls {
        margin-bottom: 0.5rem;
    }
    .item-controls label {
        margin-right: 1rem;
        font-size: 0.9em;
    }
    .item-controls input[type="checkbox"] {
        width: auto;
        margin-right: 0.3rem;
        vertical-align: middle;
    }
    .item-controls select {
        width: auto;
        padding: 0.2rem;
        font-size: 0.9em;
        display: inline-block;
        vertical-align: middle;
    }
    .seat-icons {
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px dashed #eee;
        min-height: 35px;
    }
    .seat-icon {
        display: inline-block;
        min-width: 50px; /* Increased width for text */
        height: 30px;
        padding: 0 5px; /* Add padding */
        border: 1px solid #ccc;
        border-radius: 4px;
        margin-right: 5px;
        margin-bottom: 5px;
        text-align: center;
        line-height: 30px;
        font-size: 0.8em;
        cursor: pointer;
        background-color: #e0e0e0;
        font-weight: bold;
        user-select: none;
    }
    .seat-icon.booster { background-color: #a5d6a7; color: #1b5e20; }
    .seat-icon.rear-facing { background-color: #ffcc80; color: #e65100; }
    .seat-icon.is-configuring {
        box-shadow: 0 0 5px #007bff;
    }
    .config-buttons {
        margin-top: 1rem;
        text-align: right;
    }
     .config-buttons button {
        margin-left: 0.5rem;
     }
    .inline-edit-remove {
       font-size: 0.8em;
    }
     .inline-edit-remove button {
        margin-left: 0.3rem;
        padding: 0.1rem 0.4rem;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.2em;
        vertical-align: middle;
     }
     .inline-edit-remove button.edit-btn { color: #6c757d; }
     .inline-edit-remove button.remove-btn { color: #dc3545; }
     .placeholder-text {
        color: #888;
        font-style: italic;
        cursor: pointer;
        border-bottom: 1px dashed #ccc;
        padding: 0.1rem 0;
     }
     .inline-input {
       border: 1px solid #ccc;
       padding: 0.2rem;
       font-size: 1em;
       margin: 0;
       vertical-align: baseline;
     }
     
     /* Child allocation status styles */
     .child-card.fully-allocated {
       background-color: #e8f5e9;
       border-left: 4px solid #4caf50;
     }
     .child-card.partially-allocated {
       background-color: #fff3e0;
       border-left: 4px solid #ff9800;
     }
     .child-card.unallocated {
       background-color: #ffebee;
       border-left: 4px solid #f44336;
     }

     /* Seat styles on allocation board */
     .seat {
      margin-top: 0.5rem; /* Reduced margin */
      padding: 0.5rem;
      border: 2px dashed #aaa;
      border-radius: 4px;
      min-height: 40px; /* Reduced height */
      display: flex;
      align-items: center;
      justify-content: center; /* Keep centered */
      font-size: 0.85em; /* Slightly smaller font if needed */
      color: #555;
    }
    .seat.seat-occupied {
        background: #c8e6c9;
        border-style: solid;
        border-color: #81c784;
        color: #1b5e20;
        font-weight: bold;
    }
    .seat.seat-available {
        background: #eeeeee;
        border-style: dashed;
        border-color: #bdbdbd;
        color: #616161;
    }

  </style>
</head>
<body>
  <!-- DEBUG MARKER Removed -->
  <script>console.log("DEBUG: BODY MARKER - Latest file version loaded");</script> <!-- Keeping console log for now -->
  <div class="header-container">
    <h1>Carpool Matcher</h1>
    <div class="header-actions">
      <button id="clearAllocationsBtn" class="danger" title="Clear all child assignments but keep drivers/children">Clear Allocations</button>
      <button id="clearDataBtn" class="danger" title="Clear ALL data including drivers and children">Clear All Data</button>
    </div>
  </div>

  <script>
    // Add clear allocations button functionality
    document.getElementById('clearAllocationsBtn').addEventListener('click', function() {
      if (confirm('Clear all child assignments while keeping drivers and children?')) {
        clearAllAllocations();
        alert('All child assignments have been cleared.');
      }
    });
    // Add clear data functionality
    document.getElementById('clearDataBtn').addEventListener('click', function() {
      if (confirm('Are you sure you want to clear ALL data? This cannot be undone.')) {
        // Clear localStorage using correct keys
        localStorage.removeItem('drivers');
        localStorage.removeItem('children');
        
        // Reset in-memory arrays
        drivers = [];
        children = [];
        
        // Refresh UI
        render();
        
        console.log('DEBUG: Cleared localStorage drivers:', localStorage.getItem('drivers'));
        console.log('DEBUG: Cleared localStorage children:', localStorage.getItem('children'));
        alert('All data has been cleared. Page will now refresh.');
        location.reload();
      }
    });

    // Add clear allocations only functionality
    function clearAllAllocations() {
      // Clear all seat assignments but keep drivers and children
      drivers.forEach(driver => {
        driver.seats = driver.seats.map(seat => {
          // Preserve seat type, clear assignments
          return {...seat, assignedPickup: null, assignedDropoff: null}; 
        });
      });
       children.forEach(child => {
           child.assignedPickup = null;
           child.assignedDropoff = null;
       });
      
      // Update storage and UI
      saveData();
      render();
    }
  </script>

  <!-- Templates for Visual Elements -->
  <template id="carTemplate">
    <div class="item-container car-container" draggable="false"> <!-- Draggable set by JS -->
      <div style="display: flex; justify-content: space-between; align-items: flex-start;">
        <h4 class="car-name"><span class="placeholder-text" data-field="name">[Click to Add Driver Name]</span></h4>
        <div class="inline-edit-remove" style="display: none;"> <!-- Hidden initially -->
          <button class="edit-btn" title="Edit">‚úèÔ∏è</button>
          <button class="clear-btn" title="Clear Allocations">üîÑ</button>
          <button class="remove-btn" title="Delete" disabled>‚ùå</button>
        </div>
      </div>
      <div class="item-controls">
        <label><input type="checkbox" class="can-pickup" data-field="canPickUp"> Pick Up</label>
        <label><input type="checkbox" class="can-dropoff" data-field="canDropOff"> Drop Off</label>
      </div>
      <div class="item-controls">
         <label>Seats: <span class="num-seats-display">0</span> </label>
         <button type="button" class="add-seat-btn secondary" style="padding: 0.1rem 0.4rem; font-size: 0.8em;">+</button>
         <button type="button" class="remove-seat-btn secondary" style="padding: 0.1rem 0.4rem; font-size: 0.8em;">-</button>
      </div>
      <div class="seat-icons">
        <!-- Seat icons will be generated here -->
      </div>
      <div class="item-controls"> <!-- Added for Comments -->
          <label for="driver-comment">Comment:</label>
          <textarea class="driver-comment" data-field="comments" style="width: 95%; min-height: 40px; margin-top: 0.3rem;" disabled></textarea> <!-- Disabled by default -->
      </div>
      <div class="comment-display" style="margin-top: 0.5rem; font-size: 0.9em; color: #555; white-space: pre-wrap;">
          <!-- Comment text will be displayed here -->
      </div>
      <div class="config-buttons"> <!-- Shown during initial config/edit -->
         <button type="button" class="save-config-btn">Save</button>
         <button type="button" class="cancel-config-btn secondary">Cancel</button>
      </div>
    </div>
  </template>

  <template id="childTemplate">
     <div class="item-container child-card" draggable="false"> <!-- Draggable set by JS -->
        <div class="child-details">
            <h4 class="child-name"><span class="placeholder-text" data-field="name">[Click to Add Child Name]</span></h4>
            <div class="item-controls">
                <label><input type="checkbox" class="needs-pickup" data-field="pickUp"> Needs Pick Up</label>
                <label><input type="checkbox" class="needs-dropoff" data-field="dropOff"> Needs Drop Off</label>
            </div>
            <div class="item-controls">
                <label>Seat:
                    <select class="seat-requirement" data-field="seatTypeNeeded">
                        <option value="none">None</option>
                        <option value="front-facing">Front-facing</option>
                        <option value="rear-facing">Rear-facing</option>
                        <option value="booster">Booster</option>
                    </select>
                </label>
            </div>
             <div class="config-buttons"> <!-- Shown during initial config/edit -->
                <button type="button" class="save-config-btn">Save</button>
                <button type="button" class="cancel-config-btn secondary">Cancel</button>
            </div>
        </div>
        <div class="inline-edit-remove" style="display: none;"> <!-- Hidden initially -->
          <button class="edit-btn" title="Edit">‚úèÔ∏è</button>
          <button class="clear-btn" title="Clear Allocations">üîÑ</button>
          <button class="remove-btn" title="Delete" disabled>‚ùå</button>
        </div>
     </div>
  </template>
  <!-- End Templates -->


  <!-- Setup Area -->
  <div class="setup-area">
    <div class="setup-column" id="availableCarsArea">
      <h3>Available Cars</h3>
      <button id="addCarBtn" class="add-button">+ Add Car</button>
      <!-- Configured car containers go here -->
    </div>
    <div class="setup-column" id="childrenWaitingArea">
      <h3>Children Waiting</h3>
      <button id="addChildBtn" class="add-button">+ Add Child</button>
      <!-- Configured child cards go here -->
    </div>
  </div>
  <!-- End Setup Area -->

  <h2>Allocation Boards</h2>
  <div class="swimlane-container">
    <div class="board" id="dropoffBoard">
        <h3>Drop-off Assignments (8am)</h3>
        <div class="list" id="dropoffUnassignedList">
          <h4>Unassigned (Drop-off)</h4>
           <!-- Static header, list no longer a drop target for children from setup -->
        </div>
        <div class="drivers-area" id="dropoffDriversArea">
          <!-- Assigned dropoff drivers go here -->
        </div>
    </div>
    <div class="board" id="pickupBoard">
       <h3>Pick-up Assignments (5pm)</h3>
       <div class="list" id="pickupUnassignedList">
         <h4>Unassigned (Pick-up)</h4>
         <!-- Static header, list no longer a drop target for children from setup -->
       </div>
       <div class="drivers-area" id="pickupDriversArea">
         <!-- Assigned pickup drivers go here -->
       </div>
    </div>
  </div>

  <script>
    // DEBUG LOG: Script loaded
    console.log("DEBUG: Script loaded");

    // --- Data --- (Keep outside DOMContentLoaded)
    let children = JSON.parse(localStorage.getItem('children') || '[]').map(c => ({ ...c, id: c.id || `child_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`, assignedPickup: c.assignedPickup || null, assignedDropoff: c.assignedDropoff || null, isConfigured: c.isConfigured === false ? false : true }));
    let drivers = JSON.parse(localStorage.getItem('drivers') || '[]').map(d => ({ ...d, name: d.name || 'Unnamed Driver', seats: (d.seats || []).map(s => ({ ...s, assignedPickup: s.assignedPickup || null, assignedDropoff: s.assignedDropoff || null })), isConfigured: d.isConfigured === false ? false : true, assignedToBoard: d.assignedToBoard || null, comments: d.comments || '' })); // Added comments field

    function saveData() {
      localStorage.setItem('children', JSON.stringify(children));
      localStorage.setItem('drivers', JSON.stringify(drivers));
    }
    // --- End Data ---

    document.addEventListener("DOMContentLoaded", function() {
      console.log("DEBUG: DOM fully loaded");

      // --- Template & Area References (Moved inside DOMContentLoaded) ---
      const carTemplate = document.getElementById('carTemplate');
      const childTemplate = document.getElementById('childTemplate');
      const availableCarsArea = document.getElementById('availableCarsArea');
      const childrenWaitingArea = document.getElementById('childrenWaitingArea');

      // Debug: Check if parent areas are found
      console.log("DEBUG: availableCarsArea found?", !!availableCarsArea);
      console.log("DEBUG: childrenWaitingArea found?", !!childrenWaitingArea);

      // Try finding buttons using querySelector relative to parents (or getElementById)
      // Reverting back to getElementById as querySelector didn't help and the issue seems to be render() timing
      const addCarBtn = document.getElementById('addCarBtn');
      const addChildBtn = document.getElementById('addChildBtn');

      // Allocation Board References (Moved inside DOMContentLoaded)
      const pickupUnassignedList = document.getElementById('pickupUnassignedList');
      const dropoffUnassignedList = document.getElementById('dropoffUnassignedList');
      const pickupBoard = document.getElementById('pickupBoard');
      const dropoffBoard = document.getElementById('dropoffBoard');
      const pickupDriversArea = document.getElementById('pickupDriversArea');
      const dropoffDriversArea = document.getElementById('dropoffDriversArea');
      // --- End References ---

      // Debug check using querySelector method
      // Debug check using getElementById again
      console.log("DEBUG: addCarBtn found?", !!addCarBtn);
      console.log("DEBUG: addChildBtn found?", !!addChildBtn);

      // --- Add Button / Inline Config Logic (Listeners MUST be attached before render clears elements) ---
      if (addCarBtn) {
        addCarBtn.addEventListener('click', () => {
            const tempCar = carTemplate.content.cloneNode(true).firstElementChild;
            tempCar.classList.add('is-configuring');
            tempCar.dataset.tempId = `temp-car-${Date.now()}`; // Temporary ID

            // Show config buttons, hide edit/remove (already hidden in template)
            tempCar.querySelector('.config-buttons').style.display = 'block';

            // Enable controls for configuration
            tempCar.querySelectorAll('input, button.add-seat-btn, button.remove-seat-btn').forEach(el => el.disabled = false);

            // Add listeners specific to this temporary element
            addTemporaryConfigListeners(tempCar, 'car');

            // Insert after the button
            addCarBtn.insertAdjacentElement('afterend', tempCar);
            // Focus the name placeholder/input
            tempCar.querySelector('.car-name .placeholder-text')?.click();
        });
      } else {
        console.error("DEBUG: addCarBtn not found, cannot attach listener.");
      }

      // Removed duplicated else block here

      if (addChildBtn) {
        addChildBtn.addEventListener('click', () => {
            const tempChild = childTemplate.content.cloneNode(true).firstElementChild;
            tempChild.classList.add('is-configuring');
            tempChild.dataset.tempId = `temp-child-${Date.now()}`;

            tempChild.querySelector('.config-buttons').style.display = 'block';
            tempChild.querySelectorAll('input, select').forEach(el => el.disabled = false);

            addTemporaryConfigListeners(tempChild, 'child');

            addChildBtn.insertAdjacentElement('afterend', tempChild);
            tempChild.querySelector('.child-name .placeholder-text')?.click();
        });
      } else {
        console.error("DEBUG: addChildBtn not found, cannot attach listener.");
      }

      // Initial render call - MOVED TO END of DOMContentLoaded to ensure listeners are attached first
      // render();

      // Initial render call should also be inside DOMContentLoaded
      render(); // Call render after setting up listeners and references

      // Initial render call - Moved here
      render(); // Call render AFTER setting up listeners and references

    }); // End of DOMContentLoaded

    // --- Function Definitions (Keep outside DOMContentLoaded) ---
    // ... (addTemporaryConfigListeners, enableInlineEdit, saveInlineEdit, etc.) ...
    // ... (Make sure these functions correctly use the references passed to them or defined globally/within scope) ...

    // Updated function to add listeners, handles edit mode flag
    function addTemporaryConfigListeners(element, type, isEditing = false) {
        const namePlaceholder = element.querySelector(type === 'car' ? '.car-name .placeholder-text' : '.child-name .placeholder-text');
        const nameSpan = element.querySelector(type === 'car' ? '.car-name span:not(.placeholder-text)' : '.child-name span:not(.placeholder-text)');
        const saveBtn = element.querySelector('.save-config-btn');
        const cancelBtn = element.querySelector('.cancel-config-btn');

        const nameElement = namePlaceholder || nameSpan;
        if (nameElement) {
             nameElement.onclick = () => enableInlineEdit(nameElement);
        }

        saveBtn.onclick = () => saveTemporaryConfig(element, type); // Save handles both add/update
        cancelBtn.onclick = () => {
            if (isEditing) {
                // Cancel edit: Re-render to restore original state
                render();
            } else {
                // Cancel add: Just remove the temporary element
                element.remove();
            }
        };

        // --- Car Specific Listeners ---
        if (type === 'car') {
            // If not editing, initialize temp seats. If editing, _tempSeats was set in editItemConfig
            if (!isEditing) element._tempSeats = [];

            element.querySelector('.can-pickup').onchange = null; // Clear previous if any
            element.querySelector('.can-pickup').onchange = (e) => element.dataset.canPickUp = e.target.checked;
            element.querySelector('.can-dropoff').onchange = null;
            element.querySelector('.can-dropoff').onchange = (e) => element.dataset.canDropOff = e.target.checked;
            element.querySelector('.add-seat-btn').onclick = null;
            element.querySelector('.add-seat-btn').onclick = () => addSeat(element);
            element.querySelector('.remove-seat-btn').onclick = null;
            element.querySelector('.remove-seat-btn').onclick = () => removeSeat(element);
            element.querySelector('.seat-icons').onclick = null;
            element.querySelector('.seat-icons').onclick = (e) => {
                 if (e.target.classList.contains('seat-icon')) {
                     cycleSeatType(e.target, element);
                 }
            };
            if (!isEditing) renderSeatIcons(element); // Render initial seats only if adding new

            // Enable comment textarea during config/edit
            const commentTextarea = element.querySelector('.driver-comment');
            if (commentTextarea) commentTextarea.disabled = false;
        }
        // --- Child Specific Listeners ---
        else if (type === 'child') {
             element.querySelector('.needs-pickup').onchange = null;
             element.querySelector('.needs-pickup').onchange = (e) => element.dataset.pickUp = e.target.checked;
             element.querySelector('.needs-dropoff').onchange = null;
             element.querySelector('.needs-dropoff').onchange = (e) => element.dataset.dropOff = e.target.checked;
             element.querySelector('.seat-requirement').onchange = null;
             element.querySelector('.seat-requirement').onchange = (e) => element.dataset.seatTypeNeeded = e.target.value;
             // Set initial dataset values only if adding new
             if (!isEditing) {
                 element.dataset.pickUp = element.querySelector('.needs-pickup').checked;
                 element.dataset.dropOff = element.querySelector('.needs-dropoff').checked;
                 element.dataset.seatTypeNeeded = element.querySelector('.seat-requirement').value;
             }
        }
    }

    // Inline Name Editing
    function enableInlineEdit(placeholderElement) {
        const currentText = placeholderElement.textContent.startsWith('[Click') ? '' : placeholderElement.textContent;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'inline-input';
        input.value = currentText;
        input.dataset.originalPlaceholder = placeholderElement.dataset.field; // Store field name ('name')

        placeholderElement.replaceWith(input);
        input.focus();

        input.onblur = () => saveInlineEdit(input);
        input.onkeydown = (e) => {
            if (e.key === 'Enter') input.blur();
            if (e.key === 'Escape') cancelInlineEdit(input, currentText); // Allow escape to cancel
        };
    }

    function saveInlineEdit(inputElement) {
        const newValue = inputElement.value.trim();
        const fieldName = inputElement.dataset.originalPlaceholder;
        const parentH4 = inputElement.closest('h4'); // Find parent h4

        // Create the span (placeholder or actual text)
        const newSpan = document.createElement('span');
        if (!newValue) {
            newSpan.textContent = `[Click to Add ${fieldName === 'name' ? 'Name' : 'Value'}]`; // Generic placeholder
            newSpan.className = 'placeholder-text';
            newSpan.dataset.field = fieldName;
            newSpan.onclick = () => enableInlineEdit(newSpan); // Re-attach listener
        } else {
            newSpan.textContent = newValue;
            // Make the saved text clickable again to allow re-editing *during configuration*
            newSpan.onclick = () => enableInlineEdit(newSpan);
            newSpan.dataset.field = fieldName; // Keep field name
        }

        // Store value temporarily on the container (will be read on Save Config)
        inputElement.closest('.item-container').dataset[fieldName] = newValue; // e.g., dataset.name = 'John Doe'

        inputElement.replaceWith(newSpan);
    }

     function cancelInlineEdit(inputElement, originalValue) {
         const fieldName = inputElement.dataset.originalPlaceholder;
         const parentH4 = inputElement.closest('h4');

         const newSpan = document.createElement('span');
         if (!originalValue || originalValue.startsWith('[Click')) {
             newSpan.textContent = `[Click to Add ${fieldName === 'name' ? 'Name' : 'Value'}]`;
             newSpan.className = 'placeholder-text';
             newSpan.dataset.field = fieldName;
         } else {
             newSpan.textContent = originalValue;
             newSpan.dataset.field = fieldName; // Keep field name
         }
         // Only allow re-clicking name span if configuring
         if (inputElement.closest('.is-configuring')) {
            newSpan.onclick = () => enableInlineEdit(newSpan);
         }
         inputElement.replaceWith(newSpan);
     }

    // --- Seat Management for Temporary Car (Stage 2b) ---
    function addSeat(carElement) {
        if (!carElement._tempSeats) carElement._tempSeats = [];
        carElement._tempSeats.push({ type: null }); // Add a standard seat
        renderSeatIcons(carElement);
    }

    function removeSeat(carElement) {
        if (carElement._tempSeats && carElement._tempSeats.length > 0) {
            carElement._tempSeats.pop(); // Remove the last seat
            renderSeatIcons(carElement);
        }
    }

    function cycleSeatType(seatIconElement, carElement) {
        const seatIndex = Array.from(seatIconElement.parentNode.children).indexOf(seatIconElement);
        if (!carElement._tempSeats || seatIndex >= carElement._tempSeats.length) return;

        const currentType = carElement._tempSeats[seatIndex].type;
        let nextType = null;
        // Corrected Cycle: null (Standard) -> front-facing -> rear-facing -> booster -> null
        if (currentType === null) nextType = 'front-facing';
        else if (currentType === 'front-facing') nextType = 'rear-facing';
        else if (currentType === 'rear-facing') nextType = 'booster';
        else if (currentType === 'booster') nextType = null; // Back to standard
        else nextType = 'front-facing'; // Default case if something unexpected happens

        carElement._tempSeats[seatIndex].type = nextType;
        renderSeatIcons(carElement); // Re-render to update the clicked icon
    }

    function renderSeatIcons(carElement) {
        const seatIconsContainer = carElement.querySelector('.seat-icons');
        const numSeatsDisplay = carElement.querySelector('.num-seats-display');
        const seats = carElement._tempSeats || [];

        seatIconsContainer.innerHTML = ''; // Clear existing icons
        numSeatsDisplay.textContent = seats.length;

        seats.forEach((seat, index) => {
            const icon = document.createElement('div');
            icon.className = 'seat-icon';
            icon.dataset.index = index; // Store index if needed
            let typeText = 'None';
            let typeTitle = 'None';

            if (seat.type === 'front-facing') {
                typeText = 'Front';
                typeTitle = 'Front-facing';
                icon.classList.add(seat.type);
            } else if (seat.type === 'rear-facing') {
                typeText = 'Rear';
                typeTitle = 'Rear-facing';
                icon.classList.add(seat.type);
            } else if (seat.type === 'booster') {
                typeText = 'Booster';
                typeTitle = 'Booster';
                icon.classList.add(seat.type);
            }
            // Default is None (null type)

            icon.title = typeTitle;
            icon.textContent = typeText; // Use full text
            seatIconsContainer.appendChild(icon);
        });
    }


    // Save/Update Config Logic (Handles both New and Edit)
    function saveTemporaryConfig(element, type) {
        const isEditing = element.dataset.originalName || element.dataset.originalId;

        // --- Robust Name Retrieval ---
        let name = '';
        const nameContainer = element.querySelector(type === 'car' ? '.car-name' : '.child-name'); // Target the h4 container
        const inlineInput = nameContainer?.querySelector('.inline-input'); // Check for active input

        if (inlineInput) {
            name = inlineInput.value.trim();
            // Also update dataset immediately if saving from input state
            element.dataset.name = name;
        } else {
            // Fallback to dataset or span if no input is active
            name = element.dataset.name || nameContainer?.querySelector('span')?.textContent.trim();
             // Handle case where span might still be placeholder
             if (name && name.startsWith('[Click')) {
                 name = ''; // Treat placeholder as empty name
             }
        }
        // --- End Robust Name Retrieval ---

        // --- Final Validation ---
        if (!name) {
            alert("Name is required.");
            // Try to re-focus the input if it exists, otherwise re-enable edit on span
            if (inlineInput) {
                inlineInput.focus();
            } else if (nameContainer?.querySelector('span')) {
                 enableInlineEdit(nameContainer.querySelector('span'));
            }
            return;
        }

        // --- Create/Update Object ---
        if (type === 'car') {
            const originalName = element.dataset.originalName;
            const canPickUp = element.querySelector('.can-pickup').checked;
            const canDropOff = element.querySelector('.can-dropoff').checked;
            const seatsData = element._tempSeats || [];
            const comments = element.querySelector('.driver-comment')?.value || ''; // Read comment

             if (seatsData.length === 0) {
                 alert("Please add at least one seat."); return;
             }

            // Check for name conflict only if name changed or adding new
             if (name !== originalName && drivers.some(d => d.name === name)) {
                 alert(`Driver with name "${name}" already exists. Please use a unique name.`);
                 // Re-enable inline edit on the name element if validation fails
                 if(nameContainer?.querySelector('span')) enableInlineEdit(nameContainer.querySelector('span'));
                 return;
             }

            const driverData = {
                name: name,
                canPickUp: canPickUp,
                canDropOff: canDropOff,
                seats: seatsData.map(seat => ({ type: seat.type, assignedPickup: null, assignedDropoff: null })), // Reset assignments on edit? Or preserve? Resetting for now.
                isConfigured: true,
                assignedToBoard: null, // Reset board assignment on edit? Or preserve? Resetting for now.
                comments: comments // Save comment
            };

            if (isEditing) { // Update existing driver
                const driverIndex = drivers.findIndex(d => d.name === originalName);
                if (driverIndex !== -1) {
                    // Preserve assignments if name didn't change? More complex. Resetting is simpler.
                    if (name !== originalName) {
                         removeAssignmentsForDriver(originalName); // Clear old assignments if name changed
                    } else {
                         // Preserve board assignment if name is same?
                         driverData.assignedToBoard = drivers[driverIndex].assignedToBoard;
                         // Preserve seat assignments? Even more complex. Resetting.
                         removeAssignmentsForDriver(originalName);
                    }
                    drivers[driverIndex] = { ...drivers[driverIndex], ...driverData }; // Merge updates
                    console.log("Driver Updated:", drivers[driverIndex]);
                } else {
                     console.error("Could not find driver to update:", originalName);
                     // Optionally recreate if not found? Or just cancel? Cancel for now.
                     render(); // Re-render to remove the editing UI
                     return;
                }
            } else { // Add new driver
                drivers.push(driverData);
                console.log("Driver Saved:", driverData);
            }

        } else { // type === 'child'
            const originalId = element.dataset.originalId; // Get original ID for finding existing child
            const pickUp = element.querySelector('.needs-pickup').checked;
            const dropOff = element.querySelector('.needs-dropoff').checked;
            let seatTypeNeeded = element.querySelector('.seat-requirement').value;
            // Map "none" from dropdown to null in data model
            if (seatTypeNeeded === 'none') {
                seatTypeNeeded = null;
            }

             if (!pickUp && !dropOff) {
                 alert("Child must need at least Pick Up or Drop Off."); return;
             }

             const childData = {
                name: name, // Use the name retrieved robustly above
                pickUp: pickUp,
                dropOff: dropOff,
                seatTypeNeeded: seatTypeNeeded,
                isConfigured: true,
                // Preserve assignments on edit? Resetting is simpler.
                assignedPickup: null,
                assignedDropoff: null
             };

            if (isEditing && originalId) { // Update existing child - Ensure originalId exists
                 const childIndex = children.findIndex(c => c.id === originalId);
                 if (childIndex !== -1) {
                     // Ensure ID is preserved during update
                     const existingChild = children[childIndex];
                     const updatedChildData = { ...existingChild, ...childData }; // Merge updates, keeping original ID etc.
                     removeAssignmentsForChild(originalId); // Clear old assignments before update
                     children[childIndex] = updatedChildData;
                     console.log("Child Updated:", children[childIndex]);
                 } else {
                     console.error("Could not find child to update:", originalId);
                     render(); return;
                 }
            } else { // Add new child
                childData.id = `child_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                children.push(childData);
                console.log("Child Saved:", childData);
            }
        }

        // --- Cleanup and Update ---
        saveData();
        render(); // Re-render handles removing temp/updating display
    }
    // --- End Add Button / Inline Config Logic ---


    // --- Edit/Remove Logic (Stage 4 Implementation) ---
    function editItemConfig(element, type) { // Pass type explicitly
        element.classList.add('is-configuring');
        element.draggable = false; // Disable drag while editing

        // Store original identifier in case name is changed
        if (type === 'car') {
            element.dataset.originalName = element.dataset.name;
            // Store original capabilities
            const driver = drivers.find(d => d.name === element.dataset.originalName);
            element._originalPickup = driver?.canPickUp || false;
            element._originalDropoff = driver?.canDropOff || false;
            
            // Enable controls
            element.querySelectorAll('input, button.add-seat-btn, button.remove-seat-btn').forEach(el => el.disabled = false);
            // Re-enable seat icon clicks if needed (handled by checking is-configuring?)
            element._tempSeats = driver?.seats.map(s => ({...s})) || []; // Load current seats into temp store
            renderSeatIcons(element); // Render seats for editing

            // Populate comment textarea
            const commentTextarea = element.querySelector('.driver-comment');
            if (commentTextarea) {
                commentTextarea.value = driver?.comments || '';
                commentTextarea.disabled = false; // Ensure it's enabled for editing
            }
        } else { // child
             const child = children.find(c => c.id === element.dataset.id);
             // Store original ID before enabling edit
             element.dataset.originalId = element.dataset.id; 
             // Store current name in dataset in case inline edit isn't triggered/saved
             element.dataset.name = child?.name || ''; 

             if (!child.name) {
                 // Set default name if empty - This might be redundant if placeholder handles it
                 // child.name = 'New Child'; 
                 // element.querySelector('.child-name span').textContent = 'New Child';
             }
             // Enable controls
             element.querySelectorAll('input, select').forEach(el => el.disabled = false);
        }

        // Show Save/Cancel, hide Edit/Remove
        element.querySelector('.config-buttons').style.display = 'block';
        element.querySelector('.inline-edit-remove').style.display = 'none';
        element.querySelector('.save-config-btn').textContent = 'Update Config'; // Change button text
        
        // If editing a car, check if capabilities changed and clear affected assignments
        if (type === 'car') {
            const pickupChanged = element._originalPickup !== element.querySelector('.can-pickup').checked;
            const dropoffChanged = element._originalDropoff !== element.querySelector('.can-dropoff').checked;
            
            if (pickupChanged || dropoffChanged) {
                const driverName = element.dataset.originalName;
                removeAssignmentsForDriver(driverName);
            }
        }

        // Re-attach listeners for config buttons and inline edit
        addTemporaryConfigListeners(element, type, true); // Pass flag indicating edit mode

        // Focus name field - Refined logic
        const nameContainer = element.querySelector(type === 'car' ? '.car-name' : '.child-name');
        const nameElement = nameContainer?.querySelector('span'); // Target the span specifically
        if(nameElement) {
             // Only trigger inline edit if it's not the placeholder text
             if (!nameElement.classList.contains('placeholder-text')) {
                 enableInlineEdit(nameElement);
             } else {
                 // If it is the placeholder, click it to initiate edit
                 nameElement.click();
             }
        }
    }

    // Remove function - now calls the actual removal logic
    function removeItem(element, type) {
        if (type === 'car') {
            const driverName = element.dataset.name;
            if (confirm(`Delete this driver "${driverName}" and all their assignments?`)) { // Added name to confirm
                removeAssignmentsForDriver(driverName);
                // Actual removal from data array
                drivers = drivers.filter(d => d.name !== driverName);
                saveData();
                render();
            }
        } else { // child
            const childId = element.dataset.id;
            const child = children.find(c => c.id === childId);
            if (!child) return; // Child not found

            if (!child.assignedPickup && !child.assignedDropoff) {
                if (confirm(`Delete this child "${child.name}"?`)) { // Added name to confirm
                    // Actual removal from data array
                    children = children.filter(c => c.id !== childId);
                    saveData();
                    render();
                }
            } else {
                alert(`Cannot delete child "${child.name}" with active assignments. Clear allocations first.`);
            }
        }
    }

    function clearItemAssignments(element, type) {
        if (type === 'car') {
            const driverName = element.dataset.name;
            removeAssignmentsForDriver(driverName);
            // Also clear assignments from the driver's seats in the data model
            const driver = drivers.find(d => d.name === driverName);
            if (driver) {
                driver.seats.forEach(seat => {
                    seat.assignedPickup = null;
                    seat.assignedDropoff = null;
                });
                saveData();
                render(); // Re-render the specific driver on the board
            }
        } else { // child
            const childId = element.dataset.id;
            const affectedSeats = removeAssignmentsForChild(childId); // This already saves data
            updateChildCardVisuals(childId); // Update the child card itself
            // Update the visuals for each seat that was cleared
            affectedSeats.forEach(info => {
                updateSeatVisuals(info.driverName, info.seatIndex, info.serviceType);
            });
            // No full render needed now
        }
        // render(); // Removed full render, using granular updates
    }
    // Assignment clearing helper - Modified to return affected seats
    // NOTE: This function now calls saveData() internally after clearing.
    function removeAssignmentsForChild(childId) {
        const child = children.find(c => c.id === childId);
        if (!child) return []; // Child not found

        const assignmentPropPickup = 'assignedPickup';
        const assignmentPropDropoff = 'assignedDropoff';
        const seatAssignmentPropPickup = 'assignedPickup';
        const seatAssignmentPropDropoff = 'assignedDropoff';

        const oldAssignmentPickup = child[assignmentPropPickup];
        const oldAssignmentDropoff = child[assignmentPropDropoff];
        let affectedSeatsInfo = [];

        // Clear child's assignment pointers
        child[assignmentPropPickup] = null;
        child[assignmentPropDropoff] = null;

        // --- Clear Pickup Seat ---
        if (oldAssignmentPickup) {
            const driver = drivers.find(d => d.name === oldAssignmentPickup.driverName);
            if (driver && driver.seats && oldAssignmentPickup.seatIndex < driver.seats.length) {
                const seat = driver.seats[oldAssignmentPickup.seatIndex];
                if (seat[seatAssignmentPropPickup] && seat[seatAssignmentPropPickup].id === childId) {
                    seat[seatAssignmentPropPickup] = null;
                    affectedSeatsInfo.push({ driverName: driver.name, seatIndex: oldAssignmentPickup.seatIndex, serviceType: 'pickup' });
                }
            }
        }
        // --- Clear Dropoff Seat ---
         if (oldAssignmentDropoff) {
            const driver = drivers.find(d => d.name === oldAssignmentDropoff.driverName);
            if (driver && driver.seats && oldAssignmentDropoff.seatIndex < driver.seats.length) {
                const seat = driver.seats[oldAssignmentDropoff.seatIndex];
                if (seat[seatAssignmentPropDropoff] && seat[seatAssignmentPropDropoff].id === childId) {
                    seat[seatAssignmentPropDropoff] = null;
                    affectedSeatsInfo.push({ driverName: driver.name, seatIndex: oldAssignmentDropoff.seatIndex, serviceType: 'dropoff' });
                }
            }
        }

        saveData(); // Persist changes after clearing everything
        return affectedSeatsInfo; // Return info about the seats that were cleared
    }

    function removeAssignmentsForDriver(driverName) {
       children.forEach(child => {
            if (child.assignedPickup && child.assignedPickup.driverName === driverName) child.assignedPickup = null;
            if (child.assignedDropoff && child.assignedDropoff.driverName === driverName) child.assignedDropoff = null;
        });
       // No need to save/render here, called by functions that do.
    }
    // --- End Edit/Remove Logic ---


    // --- Board Rendering & Drag/Drop Logic (Refactored for Visual UI - Stage 1) ---
    function render() {
        // --- Safer Clearing Logic ---
        // Preserve static elements (heading + button) before clearing dynamic content

        // For Available Cars Area
        const carsHeading = availableCarsArea.querySelector('h3');
        const carsAddButton = availableCarsArea.querySelector('#addCarBtn'); // Use ID selector here
        availableCarsArea.innerHTML = ''; // Clear everything
        if (carsHeading) availableCarsArea.appendChild(carsHeading); // Re-add heading
        if (carsAddButton) availableCarsArea.appendChild(carsAddButton); // Re-add button

        // For Children Waiting Area
        const childrenHeading = childrenWaitingArea.querySelector('h3');
        const childrenAddButton = childrenWaitingArea.querySelector('#addChildBtn'); // Use ID selector here
        childrenWaitingArea.innerHTML = ''; // Clear everything
        if (childrenHeading) childrenWaitingArea.appendChild(childrenHeading); // Re-add heading
        if (childrenAddButton) childrenWaitingArea.appendChild(childrenAddButton); // Re-add button

        // Clear allocation board driver areas
        pickupDriversArea.innerHTML = '';
        dropoffDriversArea.innerHTML = '';

        // Keep static headers for unassigned lists (This part seems fine)
        pickupUnassignedList.innerHTML = '<h4>Unassigned (Pick-up)</h4>';
        dropoffUnassignedList.innerHTML = '<h4>Unassigned (Drop-off)</h4>';


        // Render Children in Waiting Area
        children.forEach(child => {
            if (child.isConfigured) { // Only render configured children
                const childCard = createChildCardElement(child);
                childrenWaitingArea.appendChild(childCard);
            }
        });

        // Render all configured drivers in Available Cars area
        drivers.forEach(driver => {
            if (driver.isConfigured) {
                const carElement = createCarElement(driver);
                availableCarsArea.appendChild(carElement);
            }
        });

        // Render drivers on pickup/dropoff boards if they have those capabilities
        drivers.forEach(driver => {
            if (driver.isConfigured) {
                if (driver.canPickUp) {
                    pickupDriversArea.appendChild(createDriverBoardElement(driver, 'pickup'));
                }
                if (driver.canDropOff) {
                    dropoffDriversArea.appendChild(createDriverBoardElement(driver, 'dropoff'));
                }
            }
            // Implicitly, unconfigured drivers are not rendered anywhere yet.
        });

        // Attach drop listeners (This might need review later if car drag/drop logic changes)
        attachBoardDropListeners();
    }

    // Creates the visual element for a *configured* child in the waiting area
    function createChildCardElement(child) {
        const card = childTemplate.content.cloneNode(true).firstElementChild;
        card.classList.add('child-card');

        // Determine allocation status
        const pickupAllocated = child.assignedPickup !== null;
        const dropoffAllocated = child.assignedDropoff !== null;
        
        if ((!child.pickUp || pickupAllocated) && (!child.dropOff || dropoffAllocated)) {
            card.classList.add('fully-allocated');
        } else if (pickupAllocated || dropoffAllocated) {
            card.classList.add('partially-allocated');
        } else {
            card.classList.add('unallocated');
        }
        card.dataset.id = child.id;
        card.dataset.name = child.name || ''; // Ensure dataset name is populated

        const nameSpan = card.querySelector('.child-name span'); // Target the span within h4
        if (child.name) {
            nameSpan.textContent = child.name;
            nameSpan.classList.remove('placeholder-text');
        } else {
            nameSpan.textContent = '[Click to Add Child Name]';
            nameSpan.classList.add('placeholder-text');
        }
        nameSpan.dataset.field = 'name'; // Ensure field is set

        card.querySelector('.needs-pickup').checked = child.pickUp;
        card.querySelector('.needs-dropoff').checked = child.dropOff;
        // Map null from data model back to "none" for the dropdown
        card.querySelector('.seat-requirement').value = child.seatTypeNeeded === null ? 'none' : child.seatTypeNeeded || 'none';

        // Hide config buttons, show edit/remove buttons
        card.querySelector('.config-buttons').style.display = 'none';
        card.querySelector('.inline-edit-remove').style.display = 'inline-block';

        // Disable controls on rendered card (enable on edit in Stage 4)
        card.querySelectorAll('input, select').forEach(el => el.disabled = true);

        // Configured children are always draggable from the waiting area
        card.draggable = true;
        card.addEventListener('dragstart', handleChildDragStart);

        // Attach Edit/Clear/Remove listeners
        card.querySelector('.edit-btn').onclick = (e) => editItemConfig(e.currentTarget.closest('.child-card'), 'child');
        card.querySelector('.clear-btn').onclick = (e) => clearItemAssignments(e.currentTarget.closest('.child-card'), 'child');
        card.querySelector('.remove-btn').onclick = (e) => removeItem(e.currentTarget.closest('.child-card'), 'child');
        
        // Update delete button state
        card.querySelector('.remove-btn').disabled = !!(child.assignedPickup || child.assignedDropoff);

        return card;
    }

     // Creates the visual element for a *configured* car in the available area
     function createCarElement(driver) {
        const car = carTemplate.content.cloneNode(true).firstElementChild;
        car.dataset.name = driver.name; // Use name as identifier for now

        const nameSpan = car.querySelector('.car-name span'); // Target span within h4
        if (driver.name) {
            nameSpan.textContent = driver.name;
            nameSpan.classList.remove('placeholder-text');
        } else {
             nameSpan.textContent = '[Click to Add Driver Name]';
             nameSpan.classList.add('placeholder-text');
        }
         nameSpan.dataset.field = 'name'; // Ensure field is set


        car.querySelector('.can-pickup').checked = driver.canPickUp;
        car.querySelector('.can-dropoff').checked = driver.canDropOff;
        car.querySelector('.num-seats-display').textContent = driver.seats.length;

        // Hide config buttons, show edit/remove buttons
        car.querySelector('.config-buttons').style.display = 'none';
        car.querySelector('.inline-edit-remove').style.display = 'inline-block';

        // Disable controls (enable on edit in Stage 4)
        car.querySelectorAll('input, button.add-seat-btn, button.remove-seat-btn, textarea.driver-comment').forEach(el => el.disabled = true);

        // Display comment
        const commentDisplay = car.querySelector('.comment-display');
        if (commentDisplay) {
            commentDisplay.textContent = driver.comments || ''; // Display saved comment
        }

        // Generate seat icons
        const seatIconsContainer = car.querySelector('.seat-icons');
        seatIconsContainer.innerHTML = ''; // Clear template seats
        driver.seats.forEach(seat => {
            const icon = document.createElement('div');
            icon.className = 'seat-icon';
            if (seat.type) {
                icon.classList.add(seat.type); // Add class for color
                icon.title = seat.type;
                // Display more descriptive text
                if (seat.type === 'front-facing') icon.textContent = 'Front';
                else if (seat.type === 'rear-facing') icon.textContent = 'Rear';
                else if (seat.type === 'booster') icon.textContent = 'Booster';
                else icon.textContent = 'None'; // Fallback
            } else {
                 icon.title = 'None';
                 icon.textContent = 'None';
            }
            seatIconsContainer.appendChild(icon);
        });

         // Configured cars are always draggable from the available area
         car.draggable = true;
         car.addEventListener('dragstart', handleCarDragStart); // Handler for dragging car *from* setup

         // Attach Edit/Clear/Remove listeners
         car.querySelector('.edit-btn').onclick = (e) => editItemConfig(e.currentTarget.closest('.car-container'), 'car');
         car.querySelector('.clear-btn').onclick = (e) => clearItemAssignments(e.currentTarget.closest('.car-container'), 'car');
         car.querySelector('.remove-btn').onclick = (e) => removeItem(e.currentTarget.closest('.car-container'), 'car'); // Changed type to 'car'

        return car;
     }


    // Creates the driver element *for the allocation board*
    function createDriverBoardElement(driver, serviceType) {
        const container = document.createElement('div');
        container.className = 'driver'; // Use existing board styles
        container.dataset.driverName = driver.name;
        container.dataset.serviceType = serviceType; // Keep service type

        const header = document.createElement('h4'); // Use h4 for board drivers
        header.textContent = driver.name;
        header.style.marginTop = '0';
        header.style.marginBottom = '0.5rem';
        container.appendChild(header);

        // Render seats
        driver.seats.forEach((seat, idx) => {
          const seatDiv = document.createElement('div');
          const assignedChild = serviceType === 'pickup' ? seat.assignedPickup : seat.assignedDropoff;

          seatDiv.className = 'seat';
          seatDiv.classList.add(assignedChild ? 'seat-occupied' : 'seat-available');
          seatDiv.dataset.driverName = driver.name;
          seatDiv.dataset.seatIndex = idx;
          seatDiv.dataset.serviceType = serviceType;

          if (assignedChild) {
            seatDiv.textContent = assignedChild.name;
            // Add draggable attribute and listener only if occupied
            seatDiv.draggable = true;
            seatDiv.addEventListener('dragstart', handleSeatChildDragStart);
          } else {
            // Display more descriptive text for available seats
            let seatTypeText = 'None';
            if (seat.type === 'front-facing') seatTypeText = 'Front';
            else if (seat.type === 'rear-facing') seatTypeText = 'Rear';
            else if (seat.type === 'booster') seatTypeText = 'Booster';
            seatDiv.innerHTML = `Seat ${idx + 1} (${seatTypeText})`;
            // Make non-occupied seats non-draggable
            seatDiv.draggable = false;
            seatDiv.removeEventListener('dragstart', handleSeatChildDragStart); // Ensure listener removed
          }

          seatDiv.addEventListener('dragover', (e) => e.preventDefault());
          seatDiv.addEventListener('drop', handleDropOnSeat); // Existing drop handler for children
          container.appendChild(seatDiv);
        });

        // Add drag listener to allow dragging back to setup area
        container.draggable = true;
        container.addEventListener('dragstart', handleBoardCarDragStart); // Handler for dragging car *from* board

        return container;
    }

    // --- Drag Handlers ---
    function handleChildDragStart(e) { // For children from waiting area
      const childCard = e.target.closest('.child-card');
      if (!childCard) return;
      e.dataTransfer.setData('text/plain', childCard.dataset.id); // Child ID
      e.dataTransfer.setData('application/carpool-item-type', 'child-from-waiting');
    }

    function handleCarDragStart(e) { // For cars from setup area
        e.dataTransfer.setData('text/plain', e.target.closest('.car-container').dataset.name); // Driver Name
        e.dataTransfer.setData('application/carpool-item-type', 'driver');
    }

     function handleBoardCarDragStart(e) { // For cars from board area
        const driverElement = e.target.closest('.driver');
        if (!driverElement) return;
        e.dataTransfer.setData('text/plain', driverElement.dataset.driverName); // Driver Name
        e.dataTransfer.setData('application/carpool-item-type', 'driver-on-board');
        e.dataTransfer.setData('application/carpool-source-board', driverElement.dataset.serviceType); // Track source board
    }

    function handleSeatChildDragStart(e) { // For children dragged FROM a seat
        const seatDiv = e.target.closest('.seat');
        if (!seatDiv || !seatDiv.classList.contains('seat-occupied')) {
            e.preventDefault(); // Should not happen if listener attached correctly
            return;
        }
        const serviceType = seatDiv.dataset.serviceType;
        const seatDataProp = serviceType === 'pickup' ? 'assignedPickup' : 'assignedDropoff';
        const driver = drivers.find(d => d.name === seatDiv.dataset.driverName);
        const seat = driver?.seats[parseInt(seatDiv.dataset.seatIndex, 10)];
        const childId = seat?.[seatDataProp]?.id;

        if (!childId) {
             e.preventDefault(); // No child assigned? Prevent drag.
             return;
        }

        e.dataTransfer.setData('text/plain', childId);
        e.dataTransfer.setData('application/carpool-item-type', 'child-from-seat');
        e.dataTransfer.setData('application/carpool-source-service', serviceType); // Need to know which service to unassign
    }

    // Drop handler for allocation boards (to receive cars)
    function handleDropOnBoard(e) {
        e.preventDefault();
        const itemType = e.dataTransfer.getData('application/carpool-item-type');
        const driverName = e.dataTransfer.getData('text/plain');
        const targetBoard = e.currentTarget; // The board div (pickupBoard or dropoffBoard)
        const targetBoardType = targetBoard.id === 'pickupBoard' ? 'pickup' : 'dropoff';

        if (itemType === 'driver') { // Driver dragged from setup
            const driver = drivers.find(d => d.name === driverName);
            if (driver) {
                 const canDoService = targetBoardType === 'pickup' ? driver.canPickUp : driver.canDropOff;
                 if (!canDoService) {
                     alert(`${driver.name} cannot perform ${targetBoardType} service.`);
                     return;
                 }
                 driver.assignedToBoard = targetBoardType;
                 saveData();
                 render();
            }
        } else if (itemType === 'driver-on-board') { // Driver dragged from another board
             const driver = drivers.find(d => d.name === driverName);
             if (driver) {
                 const canDoService = targetBoardType === 'pickup' ? driver.canPickUp : driver.canDropOff;
                 if (!canDoService) {
                     alert(`${driver.name} cannot perform ${targetBoardType} service.`);
                     return;
                 }
                 if (driver.assignedToBoard !== targetBoardType) {
                     driver.assignedToBoard = targetBoardType;
                     saveData();
                     render();
                 }
             }
        }
        // Ignore children dropped directly on board
    }

     // Drop handler for setup areas (to receive cars dragged back from boards)
     function handleDropOnSetupArea(e) {
         e.preventDefault();
         const itemType = e.dataTransfer.getData('application/carpool-item-type');
         const driverName = e.dataTransfer.getData('text/plain');

         if (itemType === 'driver-on-board') { // Only accept drivers from boards
             const driver = drivers.find(d => d.name === driverName);
             if (driver) {
                 driver.assignedToBoard = null; // Unassign from board
                 saveData();
                 render();
             }
         }
     }


    // Attach drop listeners to boards and setup areas
    function attachBoardDropListeners() {
        pickupBoard.addEventListener('dragover', (e) => e.preventDefault());
        pickupBoard.addEventListener('drop', handleDropOnBoard);
        dropoffBoard.addEventListener('dragover', (e) => e.preventDefault());
        dropoffBoard.addEventListener('drop', handleDropOnBoard);
        availableCarsArea.addEventListener('dragover', (e) => e.preventDefault());
        availableCarsArea.addEventListener('drop', handleDropOnSetupArea);
        // Make Children Waiting Area a drop target for unassigning
        childrenWaitingArea.addEventListener('dragover', (e) => e.preventDefault());
        childrenWaitingArea.addEventListener('drop', handleDropOnUnassignArea); // Attach the new handler
    }

    // Drop handler for the "Children Waiting" area (to unassign children)
    function handleDropOnUnassignArea(e) {
        e.preventDefault();
        const itemType = e.dataTransfer.getData('application/carpool-item-type');
        const childId = e.dataTransfer.getData('text/plain');
        const sourceServiceType = e.dataTransfer.getData('application/carpool-source-service'); // 'pickup' or 'dropoff'

        // Only accept children dragged FROM a seat
        if (itemType !== 'child-from-seat' || !childId || !sourceServiceType) {
            console.log("DEBUG: Drop on unassign area ignored - not child from seat.");
            return;
        }

        console.log(`DEBUG: Unassigning child ${childId} from ${sourceServiceType}`);

        // Unassign the child from the specific service
        const affectedSeatInfo = unassignChild(childId, sourceServiceType);

        if (affectedSeatInfo) {
            saveData(); // Save after successful unassignment
            // Granular update is better here than full render if possible
            updateChildCardVisuals(childId);
            updateSeatVisuals(affectedSeatInfo.driverName, affectedSeatInfo.seatIndex, affectedSeatInfo.serviceType);
            // render(); // Fallback to full render if granular updates are complex
            console.log(`DEBUG: Child ${childId} unassigned from ${sourceServiceType} seat ${affectedSeatInfo.seatIndex} of driver ${affectedSeatInfo.driverName}`);
        } else {
            console.log(`DEBUG: Child ${childId} was not assigned to ${sourceServiceType}, no change needed.`);
        }
    }

    // Drop handler for seats (receives children)
    function handleDropOnSeat(e) {
      e.preventDefault();
      const itemType = e.dataTransfer.getData('application/carpool-item-type');
      // Only accept children coming from the waiting area
      if (itemType !== 'child-from-waiting') return;

      const childId = e.dataTransfer.getData('text/plain');
      const child = children.find(c => c.id === childId);
      const seatDiv = e.currentTarget; // The seat element
      const driverName = seatDiv.dataset.driverName;
      const seatIndex = parseInt(seatDiv.dataset.seatIndex, 10);
      const serviceType = seatDiv.dataset.serviceType; // 'pickup' or 'dropoff'
      const driver = drivers.find(d => d.name === driverName);

      if (!driver || !driver.seats || seatIndex >= driver.seats.length) {
          console.error("Drop error: Driver or seat index invalid."); return;
      }

      const seat = driver.seats[seatIndex];

      // Basic validation
      if (!child || !seat) {
        console.error("Drop error: Child or seat not found."); return;
      }

      // --- Validation ---
      const needsThisService = serviceType === 'pickup' ? child.pickUp : child.dropOff;
      const seatIsAvailable = serviceType === 'pickup' ? !seat.assignedPickup : !seat.assignedDropoff;
      const seatTypeMatch = !child.seatTypeNeeded || seat.type === child.seatTypeNeeded;

      if (!needsThisService) {
        alert(`${child.name} does not require ${serviceType}.`); return;
      }
      if (!seatIsAvailable) {
         alert(`Seat ${seatIndex + 1} for ${driver.name} is already occupied for ${serviceType}.`); return;
      }
      if (!seatTypeMatch) {
         alert(`Seat type mismatch: ${child.name} needs ${child.seatTypeNeeded || 'None'}, seat is ${seat.type || 'None'}.`); return; // Changed Standard to None
      }
      // --- End Validation ---

      // --- Perform Assignment ---
      // Unassign from previous location *before* assigning to new one
      const previouslyAffectedSeat = unassignChild(childId, serviceType); 

      const assignmentDetails = { name: child.name, id: child.id };
      if (serviceType === 'pickup') {
        seat.assignedPickup = assignmentDetails;
        child.assignedPickup = { driverName: driver.name, seatIndex: seatIndex };
      } else { // serviceType === 'dropoff'
        seat.assignedDropoff = assignmentDetails;
        child.assignedDropoff = { driverName: driver.name, seatIndex: seatIndex };
      }
      // --- End Assignment ---

      saveData(); // Save after all changes are made

      // Granular UI updates
      updateChildCardVisuals(childId); // Update the child card in waiting area
      updateSeatVisuals(driverName, seatIndex, serviceType); // Update the target seat
      if (previouslyAffectedSeat) { // Update the seat the child was moved FROM
          updateSeatVisuals(previouslyAffectedSeat.driverName, previouslyAffectedSeat.seatIndex, previouslyAffectedSeat.serviceType);
      }
      // render(); // Avoid full render
    }

    // Helper to unassign a child from a specific service (pickup or dropoff)
    // Returns the details of the seat it was unassigned from, if any.
    // NOTE: This function NO LONGER calls saveData(). The caller must call it.
    function unassignChild(childId, serviceType) {
        const child = children.find(c => c.id === childId);
        if (!child) return null; // Child not found

        const assignmentProp = serviceType === 'pickup' ? 'assignedPickup' : 'assignedDropoff';
        const seatAssignmentProp = serviceType === 'pickup' ? 'assignedPickup' : 'assignedDropoff';

        const oldAssignment = child[assignmentProp]; // Store old assignment details { driverName, seatIndex }
        let affectedSeatInfo = null;

        // Clear child's assignment pointer for this service
        child[assignmentProp] = null;

        // Clear seat's assignment pointer for this service, if it matches
        if (oldAssignment) {
            const driver = drivers.find(d => d.name === oldAssignment.driverName);
            if (driver && driver.seats && oldAssignment.seatIndex < driver.seats.length) {
                const seat = driver.seats[oldAssignment.seatIndex];
                if (seat[seatAssignmentProp] && seat[seatAssignmentProp].id === childId) {
                    seat[seatAssignmentProp] = null;
                    affectedSeatInfo = { driverName: driver.name, seatIndex: oldAssignment.seatIndex, serviceType: serviceType };
                }
            }
        }
        // Note: We explicitly DO NOT call saveData or render here; the calling function MUST handle it.
        return affectedSeatInfo; // Return info about the seat that was cleared
    }

    // --- Granular UI Update Functions ---

    // Updates the visual state of a single child card in the waiting area
    function updateChildCardVisuals(childId) {
        const child = children.find(c => c.id === childId);
        if (!child) return;

        const card = childrenWaitingArea.querySelector(`.child-card[data-id="${childId}"]`);
        if (!card) return; // Card might not be rendered if not configured

        // Update allocation status classes
        card.classList.remove('fully-allocated', 'partially-allocated', 'unallocated');
        const pickupAllocated = child.assignedPickup !== null;
        const dropoffAllocated = child.assignedDropoff !== null;

        if ((!child.pickUp || pickupAllocated) && (!child.dropOff || dropoffAllocated)) {
            card.classList.add('fully-allocated');
        } else if (pickupAllocated || dropoffAllocated) {
            card.classList.add('partially-allocated');
        } else {
            card.classList.add('unallocated');
        }

        // Update delete button state
        const removeBtn = card.querySelector('.remove-btn');
        if (removeBtn) {
            removeBtn.disabled = pickupAllocated || dropoffAllocated;
        }

        // Update displayed name (in case it was edited)
        const nameSpan = card.querySelector('.child-name span'); // Target span
         if (nameSpan) {
             nameSpan.textContent = child.name || '[Unnamed Child]';
             if (child.name) nameSpan.classList.remove('placeholder-text');
             else nameSpan.classList.add('placeholder-text');
         }
    }

    // Updates the visual state of a single seat on the allocation board
    function updateSeatVisuals(driverName, seatIndex, serviceType) {
        const driver = drivers.find(d => d.name === driverName);
        if (!driver || !driver.seats || seatIndex >= driver.seats.length) return;

        const seatData = driver.seats[seatIndex];
        const boardArea = serviceType === 'pickup' ? pickupDriversArea : dropoffDriversArea;
        const seatDiv = boardArea.querySelector(`.driver[data-driver-name="${driverName}"] .seat[data-seat-index="${seatIndex}"]`);

        if (!seatDiv) return; // Seat element not found on the board

        const assignedChild = serviceType === 'pickup' ? seatData.assignedPickup : seatData.assignedDropoff;

        seatDiv.classList.remove('seat-occupied', 'seat-available');
        seatDiv.innerHTML = ''; // Clear content

        if (assignedChild) {
            seatDiv.classList.add('seat-occupied');
            seatDiv.textContent = assignedChild.name;
            seatDiv.draggable = true; // Make occupied seat draggable
            // Ensure the drag listener is attached only when occupied
            seatDiv.removeEventListener('dragstart', handleSeatChildDragStart); // Remove first to prevent duplicates
            seatDiv.addEventListener('dragstart', handleSeatChildDragStart);
        } else {
            seatDiv.classList.add('seat-available');
            // Display more descriptive text for available seats
            let seatTypeText = 'None';
            if (seatData.type === 'front-facing') seatTypeText = 'Front';
            else if (seatData.type === 'rear-facing') seatTypeText = 'Rear';
            else if (seatData.type === 'booster') seatTypeText = 'Booster';
            seatDiv.innerHTML = `Seat ${seatIndex + 1} (${seatTypeText})`;
            seatDiv.draggable = false; // Empty seat not draggable
            seatDiv.removeEventListener('dragstart', handleSeatChildDragStart);
        }
    }

    // --- End Granular UI Update Functions ---


    // --- End Board Rendering & Drag/Drop Logic ---


    // --- Initial Render ---
    // render(); // Multiple render calls removed, ensure one call at the end of DOMContentLoaded setup
    // --- End Initial Render ---

  </script>
</body>
</html>
